<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · BijectiveHilbert.jl</title><meta name="title" content="API Reference · BijectiveHilbert.jl"/><meta property="og:title" content="API Reference · BijectiveHilbert.jl"/><meta property="twitter:title" content="API Reference · BijectiveHilbert.jl"/><meta name="description" content="Documentation for BijectiveHilbert.jl."/><meta property="og:description" content="Documentation for BijectiveHilbert.jl."/><meta property="twitter:description" content="Documentation for BijectiveHilbert.jl."/><meta property="og:url" content="https://computingkitchen.com/BijectiveHilbert.jl/reference/"/><meta property="twitter:url" content="https://computingkitchen.com/BijectiveHilbert.jl/reference/"/><link rel="canonical" href="https://computingkitchen.com/BijectiveHilbert.jl/reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BijectiveHilbert.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../usage/">Usage</a></li><li><a class="tocitem" href="../hilbert/">Background</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Algorithms"><span>Algorithms</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/adolgert/BijectiveHilbert.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BijectiveHilbert.Bijective.Simple2D"><a class="docstring-binding" href="#BijectiveHilbert.Bijective.Simple2D"><code>BijectiveHilbert.Bijective.Simple2D</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Simple2D(::Type{T})</p><p>The type is a data type to hold the Hilbert index. It should have enough bits to hold all bits of integer axes to encode.</p><p>The variant algorithm used differs from the usual Hilbert code because it doesn&#39;t need to know the size of the whole grid before computing the code. It looks like a slightly-rotated version of the Hilbert curve, but it has the benefit that it is 1-1 between <code>(x, y)</code> and <code>z</code>, so you can translate back and forth.</p><p>If the size of the axis values or the size of the Hilbert index are too large to be stored in the data types of the axis vector or index, then you&#39;ll see an error from a failure of <code>trunc</code>, which tries to copy values into the smaller datatype. Solve this by using a larger datatype, so UInt64 instead of UInt32.</p><p>It comes from a paper:  N. Chen, N. Wang, B. Shi, A new algorithm for encoding and decoding the Hilbert order. Software—Practice and Experience 2007; 37(8): 897–908.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fa69b0f0951cce77fd84c005b0a0d6df5ce8d4b3/src/BijectiveHilbert.jl#L22-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BijectiveHilbert.SpaceGray"><a class="docstring-binding" href="#BijectiveHilbert.SpaceGray"><code>BijectiveHilbert.SpaceGray</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SpaceGray(b, n)
SpaceGray(::Type{T}, b, n)</code></pre><p>This is an n-dimensional Hilbert curve where all <code>n</code> dimensions must have <code>b</code> bits in size. It was described in the same paper and examples as the <code>Compact</code> algorithm.</p><ul><li>Hamilton, Chris H., and Andrew Rau-Chaplin. &quot;Compact Hilbert indices for multi-dimensional data.&quot; First International Conference on Complex, Intelligent and Software Intensive Systems (CISIS&#39;07). IEEE, 2007.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fa69b0f0951cce77fd84c005b0a0d6df5ce8d4b3/src/hamilton.jl#L253-L262">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BijectiveHilbert.GlobalGray"><a class="docstring-binding" href="#BijectiveHilbert.GlobalGray"><code>BijectiveHilbert.GlobalGray</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GlobalGray(b, n)
GlobalGray(T, b, n)</code></pre><p><code>T</code> is a data type for the Hilbert index. It can be signed or unsigned, as long as it has at least <code>n * b</code> bits. <code>n</code> is the number of dimensions, and <code>b</code> is the bits per dimension, so each axis value should be between 0 and <span>$2^b - 1$</span>, inclusive, for the zero-based interface. They should be between 1 and <span>$2^b$</span>, inclusive, for the one-based interface.</p><p>The GlobalGray algorithm is an n-dimensional Hilbert curve with a simplified implementation. It follows an article, &quot;Programming the Hilbert Curve,&quot; by John Skilling, 707 (2004), http://dx.doi.org/10.1063/1.1751381. I call it &quot;Global Gray&quot; because the insight of the article is that a single, global Gray code can be applied to all np bits of a Hilbert length.</p><p>For developers, note that this algorithm relies on encoding the Hilbert index in what, to me, was a surprising order. To understand the interleaving of the Hilbert index for this algorithm, start with a 2D value where higher bits are larger subscripts, <span>$(a_4a_3a_2a_1, b_4b_3b_2b_1)$</span>. Skilling encodes this as <span>$a_4b_4a_3b_3a_2b_2a_1b_1$</span>, which looks good on paper, but it means the first element of the vector has the higher bits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fa69b0f0951cce77fd84c005b0a0d6df5ce8d4b3/src/global_gray.jl#L98-L116">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BijectiveHilbert.FaceContinuous"><a class="docstring-binding" href="#BijectiveHilbert.FaceContinuous"><code>BijectiveHilbert.FaceContinuous</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FaceContinuous(b::Int, n::Int)
FaceContinuous(::Type{T}, b::Int, n::Int)</code></pre><p>For <code>n</code> dimensions, use <code>b</code> bits of precision in this Hilbert curve. If you specify a type <code>T</code>, this will be used as the type of the Hilbert encoding. If not, the smallest unsigned integer that can hold <code>n*b</code> bits will be used for the Hilbert index data type.</p><p>This is the Butz algorithm, as presented by Lawder. Haverkort2017 says it is face continuous. The code is in lawder.c. The original paper had an error, and Lawder put a correction on his website. http://www.dcs.bbk.ac.uk/~jkl/publications.html</p><ul><li>Butz, Arthur R. &quot;Alternative algorithm for Hilbert&#39;s space-filling curve.&quot; IEEE Transactions on Computers 100.4 (1971): 424-426.</li><li>Lawder, Jonathan K. &quot;Calculation of mappings between one and n-dimensional values using the hilbert space-filling curve.&quot; School of Computer Science and Information Systems, Birkbeck College, University of London, London Research Report BBKCS-00-01 August (2000).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fa69b0f0951cce77fd84c005b0a0d6df5ce8d4b3/src/facecontinuous.jl#L1-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BijectiveHilbert.Compact"><a class="docstring-binding" href="#BijectiveHilbert.Compact"><code>BijectiveHilbert.Compact</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Compact{T,B}(m::AbstractVector{&lt;:Integer})
Compact(T, m::AbstractVector{&lt;:Integer})
Compact(m::AbstractVector{&lt;:Integer})</code></pre><p>Compact Hilbert curve algorithm for anisotropic grids where each axis can have a different number of bits.  If you don&#39;t specify type parameters they are chosen for you depending on the size of <code>m</code>.</p><p><strong>Type Parameters</strong></p><ul><li><code>T</code> - Hilbert index type (e.g., UInt64, UInt128)</li><li><code>B</code> - Coordinate type (e.g., UInt32)</li></ul><p><strong>Arguments</strong></p><ul><li><code>m</code> - Vector of bit counts, one per axis</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">c = Compact{UInt64, UInt32}([3, 2, 4])  # Dimension [2^3, 2^2, 2^4]
h = encode_hilbert_zero(c, UInt32[5, 2, 11])</code></pre><p>This code starts with the tech report and paper by Chris Hamilton. That paper and subsequent versions make a Hilbert curve for unequal side lengths without a guarantee that consecutive points are adjacent. This code will always produce a lattice-continuous Hilbert curve.</p><p>Hamilton, Chris. &quot;Compact hilbert indices.&quot; Dalhousie University, Faculty of Computer Science, Technical Report CS-2006-07 (2006).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fa69b0f0951cce77fd84c005b0a0d6df5ce8d4b3/src/compact.jl#L17-L46">source</a></section></details></article><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="BijectiveHilbert.encode_hilbert"><a class="docstring-binding" href="#BijectiveHilbert.encode_hilbert"><code>BijectiveHilbert.encode_hilbert</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">encode_hilbert(ha::HilbertAlgorithm{T}, X::Vector{A})</code></pre><p>A 1-based Hilbert encoding. Both the Hilbert index and the axes start counting at 1 instead of 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fa69b0f0951cce77fd84c005b0a0d6df5ce8d4b3/src/hilbert_algorithm.jl#L8-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BijectiveHilbert.decode_hilbert!"><a class="docstring-binding" href="#BijectiveHilbert.decode_hilbert!"><code>BijectiveHilbert.decode_hilbert!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">decode_hilbert!(ha::HilbertAlgorithm{T}, X::Vector{A})</code></pre><p>A 1-based Hilbert decode, from <a href="#BijectiveHilbert.decode_hilbert_zero!"><code>decode_hilbert_zero!</code></a>. Both the Hilbert index and the axes start counting at 1 instead of 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fa69b0f0951cce77fd84c005b0a0d6df5ce8d4b3/src/hilbert_algorithm.jl#L19-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BijectiveHilbert.encode_hilbert_zero"><a class="docstring-binding" href="#BijectiveHilbert.encode_hilbert_zero"><code>BijectiveHilbert.encode_hilbert_zero</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">encode_hilbert_zero(ha::HilbertAlgorithm{T}, X::Vector{A})</code></pre><p>Takes an n-dimensional vector <code>X</code> and returns a single integer of type <code>T</code> which orders <code>X</code> to improve spatial locality. The input <code>X</code> has multiple axes and the output is called a Hilbert index. This version is zero-based, so each axis counts from 0, and the smallest Hilbert index is 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fa69b0f0951cce77fd84c005b0a0d6df5ce8d4b3/src/global_gray.jl#L143-L150">source</a></section><section><div><pre><code class="language-julia hljs">encode_hilbert_zero(c::Compact, X)</code></pre><p>Encode a point X (0-based coordinates) to a Hilbert index (0-based).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fa69b0f0951cce77fd84c005b0a0d6df5ce8d4b3/src/compact.jl#L201-L205">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BijectiveHilbert.decode_hilbert_zero!"><a class="docstring-binding" href="#BijectiveHilbert.decode_hilbert_zero!"><code>BijectiveHilbert.decode_hilbert_zero!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">decode_hilbert_zero!(ha::HilbertAlgorithm{T}}, X::Vector{A}, h::T)</code></pre><p>Given a Hilbert index, <code>h</code>, computes an n-dimensional coordinate <code>X</code>. The type of the Hilbert index is large enought to contain the bits of all dimensions of the axis vector, <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fa69b0f0951cce77fd84c005b0a0d6df5ce8d4b3/src/global_gray.jl#L157-L163">source</a></section><section><div><pre><code class="language-julia hljs">decode_hilbert_zero!(c::Compact, X, h)</code></pre><p>Decode a Hilbert index h (0-based) to point X (0-based coordinates).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fa69b0f0951cce77fd84c005b0a0d6df5ce8d4b3/src/compact.jl#L253-L257">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../hilbert/">« Background</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 26 December 2025 01:05">Friday 26 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
