var documenterSearchIndex = {"docs":
[{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/#Quick-Start","page":"Usage","title":"Quick Start","text":"The simplest case - 2D data:\n\nusing BijectiveHilbert\nencoder = Simple2D(Int)\nh = encode_hilbert(encoder, [x, y])","category":"section"},{"location":"usage/#Choose-Your-Encoder","page":"Usage","title":"Choose Your Encoder","text":"","category":"section"},{"location":"usage/#2D-data","page":"Usage","title":"2D data","text":"Simple2D requires no setup - just specify the index type:\n\nencoder = Simple2D(Int64)","category":"section"},{"location":"usage/#N-D,-same-size-axes","page":"Usage","title":"N-D, same-size axes","text":"SpaceGray is the fastest N-D encoder. All axes must be the same power-of-two size:\n\n# 4D space, each axis 0-7 (3 bits = 2^3 = 8 values)\nencoder = SpaceGray(Int64, 3, 4)\n\nGlobalGray and FaceContinuous use the same interface but produce different curve patterns:\n\nencoder = GlobalGray(Int64, 3, 4)\nencoder = FaceContinuous(Int64, 3, 4)","category":"section"},{"location":"usage/#N-D,-different-size-axes","page":"Usage","title":"N-D, different-size axes","text":"Compact handles axes of different sizes (each must be a power of two):\n\n# 3D space: axis 1 is 0-7 (3 bits), axis 2 is 0-3 (2 bits), axis 3 is 0-15 (4 bits)\nencoder = Compact(Int64, [3, 2, 4])","category":"section"},{"location":"usage/#Encode-and-Decode","page":"Usage","title":"Encode and Decode","text":"Convert a point to a Hilbert index and back:\n\npoint = [2, 1, 7, 3]\nhilbert_index = encode_hilbert(encoder, point)\n\npoint_out = zeros(Int, 4)\ndecode_hilbert!(encoder, point_out, hilbert_index)\n@assert point_out == point\n\nFor zero-based indexing, use the _zero variants:\n\npoint = [1, 0, 6, 2]\nhilbert_index = encode_hilbert_zero(encoder, point)\ndecode_hilbert_zero!(encoder, point_out, hilbert_index)","category":"section"},{"location":"usage/#Sorting","page":"Usage","title":"Sorting","text":"Sort a Vector{<:AbstractVector} according to a Hilbert curve:\n\npoints = [rand(3) for _ in 1:1000]\nhilbertsort!(points)\n\nMethods for matrix arguments are also supported:\n\npoints_mat = permutedims(reduce(hcat, points))\nhilbertsort!(points_mat)","category":"section"},{"location":"usage/#Performance-Tips","page":"Usage","title":"Performance Tips","text":"Use StaticArrays.MVector for the point vector when encoding/decoding in a tight loop\nThe 1-based functions are thin wrappers around the 0-based implementations","category":"section"},{"location":"hilbert/#Pseudo-Hilbert-Curves-for-Computational-Science","page":"Background","title":"Pseudo-Hilbert Curves for Computational Science","text":"","category":"section"},{"location":"hilbert/#Introduction","page":"Background","title":"Introduction","text":"The Pseudo-Hilbert curve sorts regular arrays of points into a linear order that keeps nearby points in the array close to each other in the linear order. Scientific computing algorithms use this capability in a few ways.\n\nAn easy form of clustering.\nSpeed up queries for databases.\nAllocate work for distributed computing.\nVisualize correlation of large one-dimensional datasets.\nVisualize change over time of two-dimensional datasets.\nApply a one-dimensional global optimization algorithm to a multi-dimensional dataset.\nAn R-tree algorithm that uses Hilbert curves to pick node locations.\n\nThese widely different applications all use the Hilbert curve, not for drawing, but to convert indices from multiple dimensions to a single dimension and to convert them back to multiple dimensions, as needed. For high performance computing, it's not a drawn curve but an algorithm.","category":"section"},{"location":"hilbert/#The-algorithm","page":"Background","title":"The algorithm","text":"There are two functions. One accepts an array of natural numbers as input and returns a single Hilbert index as output. We call that encoding. The other function decodes the single Hilbert index into the original natural numbers. There are a lot of pairs of functions that can do this.\n\nFor instance, you may recall from your earliest math class that we use such a pair of functions to prove that the number of integers in the first quadrant of a two-dimensional graph are countably infinite. Starting from (0, 0), move to (0, 1) and then (1, 0). Then move from (2, 0) to (1, 1) to (0, 2). This weaves along diagonals (in boustrophedon order), sweeping out a one-dimensional covering of two dimensions. Each point in 2D has a corresponding, countable point in 1D. Nor is this the only example, by far.\n\nJulia stores its matrices in column-major order. C stores its matrices in row-major order. Both are orderings of two-dimensional rectangles according to a linear storage order. So, too, is block storage of data. These are functions like the Hilbert curve because we can automatically translate from (i, j) to a single index in memory, if we know the dimensions of the matrix.\n\nThe Hilbert algorithm is equivalent to the use of column-major order with one addition. Two points near each other according to the Hilbert index will tend to be closer to each other if we measure the Euclidean distance between their two-dimensional indices. There isn't a guaranteed upper bound on how far apart two points can be, but experiments comparing nearness, called spatial locality, confirm that the Hilbert curve tends to arrange points closer to each other than does column-major storage, block storage, or other self-similar space-filling curves, such as the Peano curve.\n\nThat's why this algorithm is useful. Given a bunch of (i, j) indices, the Hilbert index helps to arrange them in a single vector such that nearby indices tend to be closer to each other. Using a Hilbert algorithm can be a little more complicated than that, only because tradition asks that you focus on counts of bits. Let's look at why this is an easy, if important, requirement.","category":"section"},{"location":"hilbert/#Counting-bits","page":"Background","title":"Counting bits","text":"Like a column-major order for a matrix, a Hilbert algorithm needs to know, before doing a conversion, what extent the data might have. Most implementations of Hilbert curves assume that every dimension of the input coordinates will have the same size and will be a power of two. If your data is 25 x 38, that means you need a 64 x 64 grid on which to work. That means the i-axis requires 6 bits and the j-axis requires 6-bits. As a result, the Hilbert index will run from 0 to 4095, needing 12-bits in which to store its result.\n\nIf we don't use the full size of the allocated axes, are we not going to get as good spatial locality from the Hilbert curve? This is only approximate to start with. The way to use this algorithm is to create axes that are large enough and not worry about the unused bits of information.\n\nThe bit count matters for choosing types of function arguments. It's usually easy for the coordinates to hold their integer data, but higher dimensions can make the resulting Hilbert index too large for most data types. Eight dimensions of ten bits is 80 bits, which exceeds a typical Int64. That's fine in Julia, which has both Int128 and BigInt types. In addition, most of the math is defined for unsigned integers, but the algorithms in this library are tested to work up to the last sign-bit for signed integers, so they are OK to use.","category":"section"},{"location":"hilbert/#Properties-of-different-Hilbert-curves","page":"Background","title":"Properties of different Hilbert curves","text":"There are multiple Hilbert curves. There is even a paper called, \"How many three-dimensional Hilbert curves are there?\" by Haverkort (2017). The different curves have different orientataions relative to their axes. They can be symmetric or asymmetric. They fill space in slightly different ways, (almost) all of which require domains that are powers of two in each direction. Haverkort also wrote a lovely paper describing these differences, in \"Sixteen space-filling curves and traversals for d-dimensional cubes and simplices.\"\n\nFor use in scientific computing, it may be more important to judge different Hilbert curve algorithms on capability, speed, and relaxation of constraints.\n\nThe Simple2D algorithm doesn't need to know how large the axes may be before you use it, but it only works in 2D.\nThe GlobalGray algorithm is fast for an n-dimensional algorithm.\nThe FaceContinuous algorithm is slower and is included because it has a different shape and is historically important as the first non-recursive n-dimensional algorithm.\n\nIn general, algorithms that are written explicitly for 2D are faster than n-dimensional equivalents.","category":"section"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#Algorithms","page":"API Reference","title":"Algorithms","text":"","category":"section"},{"location":"reference/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"reference/#BijectiveHilbert.Bijective.Simple2D","page":"API Reference","title":"BijectiveHilbert.Bijective.Simple2D","text":"Simple2D(::Type{T})\n\nThe type is a data type to hold the Hilbert index. It should have enough bits to hold all bits of integer axes to encode.\n\nThe variant algorithm used differs from the usual Hilbert code because it doesn't need to know the size of the whole grid before computing the code. It looks like a slightly-rotated version of the Hilbert curve, but it has the benefit that it is 1-1 between (x, y) and z, so you can translate back and forth.\n\nIf the size of the axis values or the size of the Hilbert index are too large to be stored in the data types of the axis vector or index, then you'll see an error from a failure of trunc, which tries to copy values into the smaller datatype. Solve this by using a larger datatype, so UInt64 instead of UInt32.\n\nIt comes from a paper:  N. Chen, N. Wang, B. Shi, A new algorithm for encoding and decoding the Hilbert order. Software—Practice and Experience 2007; 37(8): 897–908.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BijectiveHilbert.SpaceGray","page":"API Reference","title":"BijectiveHilbert.SpaceGray","text":"SpaceGray(b, n)\nSpaceGray(::Type{T}, b, n)\n\nThis is an n-dimensional Hilbert curve where all n dimensions must have b bits in size. It was described in the same paper and examples as the Compact algorithm.\n\nHamilton, Chris H., and Andrew Rau-Chaplin. \"Compact Hilbert indices for multi-dimensional data.\" First International Conference on Complex, Intelligent and Software Intensive Systems (CISIS'07). IEEE, 2007.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BijectiveHilbert.GlobalGray","page":"API Reference","title":"BijectiveHilbert.GlobalGray","text":"GlobalGray(b, n)\nGlobalGray(T, b, n)\n\nT is a data type for the Hilbert index. It can be signed or unsigned, as long as it has at least n * b bits. n is the number of dimensions, and b is the bits per dimension, so each axis value should be between 0 and 2^b - 1, inclusive, for the zero-based interface. They should be between 1 and 2^b, inclusive, for the one-based interface.\n\nThe GlobalGray algorithm is an n-dimensional Hilbert curve with a simplified implementation. It follows an article, \"Programming the Hilbert Curve,\" by John Skilling, 707 (2004), http://dx.doi.org/10.1063/1.1751381. I call it \"Global Gray\" because the insight of the article is that a single, global Gray code can be applied to all np bits of a Hilbert length.\n\nFor developers, note that this algorithm relies on encoding the Hilbert index in what, to me, was a surprising order. To understand the interleaving of the Hilbert index for this algorithm, start with a 2D value where higher bits are larger subscripts, (a_4a_3a_2a_1 b_4b_3b_2b_1). Skilling encodes this as a_4b_4a_3b_3a_2b_2a_1b_1, which looks good on paper, but it means the first element of the vector has the higher bits.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BijectiveHilbert.FaceContinuous","page":"API Reference","title":"BijectiveHilbert.FaceContinuous","text":"FaceContinuous(b::Int, n::Int)\nFaceContinuous(::Type{T}, b::Int, n::Int)\n\nFor n dimensions, use b bits of precision in this Hilbert curve. If you specify a type T, this will be used as the type of the Hilbert encoding. If not, the smallest unsigned integer that can hold n*b bits will be used for the Hilbert index data type.\n\nThis is the Butz algorithm, as presented by Lawder. Haverkort2017 says it is face continuous. The code is in lawder.c. The original paper had an error, and Lawder put a correction on his website. http://www.dcs.bbk.ac.uk/~jkl/publications.html\n\nButz, Arthur R. \"Alternative algorithm for Hilbert's space-filling curve.\" IEEE Transactions on Computers 100.4 (1971): 424-426.\nLawder, Jonathan K. \"Calculation of mappings between one and n-dimensional values using the hilbert space-filling curve.\" School of Computer Science and Information Systems, Birkbeck College, University of London, London Research Report BBKCS-00-01 August (2000).\n\n\n\n\n\n","category":"type"},{"location":"reference/#BijectiveHilbert.Compact","page":"API Reference","title":"BijectiveHilbert.Compact","text":"Compact{T,B}(m::AbstractVector{<:Integer})\nCompact(T, m::AbstractVector{<:Integer})\nCompact(m::AbstractVector{<:Integer})\n\nCompact Hilbert curve algorithm for anisotropic grids where each axis can have a different number of bits.  If you don't specify type parameters they are chosen for you depending on the size of m.\n\nType Parameters\n\nT - Hilbert index type (e.g., UInt64, UInt128)\nB - Coordinate type (e.g., UInt32)\n\nArguments\n\nm - Vector of bit counts, one per axis\n\nExample\n\nc = Compact{UInt64, UInt32}([3, 2, 4])  # Dimension [2^3, 2^2, 2^4]\nh = encode_hilbert_zero(c, UInt32[5, 2, 11])\n\nThis code starts with the tech report and paper by Chris Hamilton. That paper and subsequent versions make a Hilbert curve for unequal side lengths without a guarantee that consecutive points are adjacent. This code will always produce a lattice-continuous Hilbert curve.\n\nHamilton, Chris. \"Compact hilbert indices.\" Dalhousie University, Faculty of Computer Science, Technical Report CS-2006-07 (2006).\n\n\n\n\n\n","category":"type"},{"location":"reference/#BijectiveHilbert.encode_hilbert","page":"API Reference","title":"BijectiveHilbert.encode_hilbert","text":"encode_hilbert(ha::HilbertAlgorithm{T}, X::Vector{A})\n\nA 1-based Hilbert encoding. Both the Hilbert index and the axes start counting at 1 instead of 0.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BijectiveHilbert.decode_hilbert!","page":"API Reference","title":"BijectiveHilbert.decode_hilbert!","text":"decode_hilbert!(ha::HilbertAlgorithm{T}, X::Vector{A})\n\nA 1-based Hilbert decode, from decode_hilbert_zero!. Both the Hilbert index and the axes start counting at 1 instead of 0.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BijectiveHilbert.encode_hilbert_zero","page":"API Reference","title":"BijectiveHilbert.encode_hilbert_zero","text":"encode_hilbert_zero(ha::HilbertAlgorithm{T}, X::Vector{A})\n\nTakes an n-dimensional vector X and returns a single integer of type T which orders X to improve spatial locality. The input X has multiple axes and the output is called a Hilbert index. This version is zero-based, so each axis counts from 0, and the smallest Hilbert index is 0.\n\n\n\n\n\nencode_hilbert_zero(c::Compact, X)\n\nEncode a point X (0-based coordinates) to a Hilbert index (0-based).\n\n\n\n\n\n","category":"function"},{"location":"reference/#BijectiveHilbert.decode_hilbert_zero!","page":"API Reference","title":"BijectiveHilbert.decode_hilbert_zero!","text":"decode_hilbert_zero!(ha::HilbertAlgorithm{T}}, X::Vector{A}, h::T)\n\nGiven a Hilbert index, h, computes an n-dimensional coordinate X. The type of the Hilbert index is large enought to contain the bits of all dimensions of the axis vector, X.\n\n\n\n\n\ndecode_hilbert_zero!(c::Compact, X, h)\n\nDecode a Hilbert index h (0-based) to point X (0-based coordinates).\n\n\n\n\n\n","category":"function"},{"location":"reference/#BijectiveHilbert.hilbertsort","page":"API Reference","title":"BijectiveHilbert.hilbertsort","text":"hilbertsort(pts; kwargs...)\n\nThis returns a sorted copy of pts. See docstrings for hilbertsort!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BijectiveHilbert.hilbertsort!","page":"API Reference","title":"BijectiveHilbert.hilbertsort!","text":"hilbertsort!(pts::AbstractVector{<:AbstractVector};\n             encoder=default_encoder(pts),\n             bits_per_axis=max_bits_per_axis(length(first(pts))))\n\nSorts pts using a Hilbert space-filling curve in-place.\n\n\n\n\n\n","category":"function"},{"location":"#BijectiveHilbert","page":"Home","title":"BijectiveHilbert","text":"Five Hilbert curve algorithms, implemented from original papers, with bug fixes. Type stable, tested exhastively, including a new continuous curve for domains with unequal side lengths.\n\nSee Usage for full API documentation.\n\njulia> using Pkg; Pkg.add(\"BijectiveHilbert\")\njulia> using BijectiveHilbert\njulia> xy_coordinates = zeros(Int, 8, 8)\njulia> for y in 1:size(xy_coordinates, 2)\n           for x in 1:size(xy_coordinates, 1)\n               z = encode_hilbert(Simple2D(Int), [x, y])\n               xy_coordinates[x, y] = z\n           end\n       end\njulia> xy_coordinates\n8×8 Array{Int64,2}:\n  1   2  15  16  17  20  21  22\n  4   3  14  13  18  19  24  23\n  5   8   9  12  31  30  25  26\n  6   7  10  11  32  29  28  27\n 59  58  55  54  33  36  37  38\n 60  57  56  53  34  35  40  39\n 61  62  51  52  47  46  41  42\n 64  63  50  49  48  45  44  43\njulia> X = zeros(Int, 2)\njulia> decode_hilbert!(Simple2D(Int), X, xy_coordinates[5, 7])\njulia> X == [5, 7]\n\nThis function, called a Hilbert curve, is used most often for geospatial work or database implementation but is equally appropriate for dealing with large TIFF files. It belongs to the class of space-filling, self-avoiding, simple, and self-similar (FASS) curves, which includes Peano curves, and Morton z-curves.","category":"section"},{"location":"#Which-algorithm-should-I-use?","page":"Home","title":"Which algorithm should I use?","text":"Data shape Algorithm Notes\n2D Simple2D Fastest. No setup required.\nN-Dimensions, same-size axes SpaceGray Fastest N-D. Axes must be powers of two.\nN-Dimensions, different-size axes Compact Axes can be different sizes (all powers of two).\nN-D, need specific pattern GlobalGray, FaceContinuous Alternative curve shapes.","category":"section"},{"location":"#Release-Notes","page":"Home","title":"Release Notes","text":"Version Date Changes\n0.6.0 2025-12-28 Created continuous curve for unequal side lengths\n0.5.0 2025-04-14 Simple2D is 2x faster, added support for StaticArrays\n0.4.0 2023-12-29 Removed Compact from interface, comprehensive test suite\n0.3.0 2021-03-01 Made Simple2D type-stable, combinatorial testing\n0.2.0 2021-02-03 Fixed bitshifting bug, improved GlobalGray type handling\n0.1.0 2020-12-17 Initial release","category":"section"}]
}
