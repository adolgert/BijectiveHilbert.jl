<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · BijectiveHilbert.jl</title><meta name="title" content="Usage · BijectiveHilbert.jl"/><meta property="og:title" content="Usage · BijectiveHilbert.jl"/><meta property="twitter:title" content="Usage · BijectiveHilbert.jl"/><meta name="description" content="Documentation for BijectiveHilbert.jl."/><meta property="og:description" content="Documentation for BijectiveHilbert.jl."/><meta property="twitter:description" content="Documentation for BijectiveHilbert.jl."/><meta property="og:url" content="https://adolgert.github.io/BijectiveHilbert.jl/usage/"/><meta property="twitter:url" content="https://adolgert.github.io/BijectiveHilbert.jl/usage/"/><link rel="canonical" href="https://adolgert.github.io/BijectiveHilbert.jl/usage/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BijectiveHilbert.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Usage</a><ul class="internal"><li><a class="tocitem" href="#Create-an-encoder"><span>Create an encoder</span></a></li><li><a class="tocitem" href="#Encode-and-Decode"><span>Encode and Decode</span></a></li><li><a class="tocitem" href="#Example-bit-calculations"><span>Example bit calculations</span></a></li><li class="toplevel"><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><span class="tocitem">Algorithms</span><ul><li><a class="tocitem" href="../hilbert/">Pseudo-Hilbert Curves for Computational Science</a></li><li><a class="tocitem" href="../simple2d/">Simple2D</a></li><li><a class="tocitem" href="../globalgray/">Global Gray</a></li><li><a class="tocitem" href="../compact/">SpaceGray and Compact</a></li><li><a class="tocitem" href="../facecontinuous/">Face Continuous</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/adolgert/BijectiveHilbert.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/main/docs/src/usage.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h1><h2 id="Create-an-encoder"><a class="docs-heading-anchor" href="#Create-an-encoder">Create an encoder</a><a id="Create-an-encoder-1"></a><a class="docs-heading-anchor-permalink" href="#Create-an-encoder" title="Permalink"></a></h2><pre><code class="language-julia hljs">    simple = Simple2D(HilbertType)
    sg = SpaceGray(HilbertType, bits, dimensions)
    gg = GlobalGray(HilbertType, bits, dimensions)
    sg = FaceContinuous(HilbertType, bits, dimensions)</code></pre><ul><li><p><code>HilbertType</code> is an unsigned integer DataType large enough to hold the HilbertIndex. The returned HilbertIndex will have this type. Examples are <code>UInt32</code> and <code>UInt128</code>.</p></li><li><p><code>bits</code> is the maximum bit width of a DataType that can hold the Cartesian index in each dimension. If <code>bits</code> is 7, that means all indices are between 1 and <code>128=2^7</code> or between 0 and <code>127=2^7-1</code>.</p></li><li><p><code>dimension</code> is the integer number of Cartesian dimensions.</p></li></ul><p><a href="../simple2d/#Simple2D"><code>Simple2D</code></a> doesn&#39;t need to know dimensions ahead of time.</p><h2 id="Encode-and-Decode"><a class="docs-heading-anchor" href="#Encode-and-Decode">Encode and Decode</a><a id="Encode-and-Decode-1"></a><a class="docs-heading-anchor-permalink" href="#Encode-and-Decode" title="Permalink"></a></h2><pre><code class="language-julia hljs">    hilbert_index = encode_hilbert(encoder, cartesian::AbstractVector)
    decode_hilbert!(encoder, cartesian, hilbert_index)</code></pre><p>This converts from Cartesian indices in a vector to an integer Hilbert index. Then it converts back to Cartesian. decoding overwrites the cartesian array values. The input Cartesian vector may have any AbstractVector type. It can be faster if you use a <code>StaticArrays.MVector</code> of fixed size.</p><pre><code class="language-julia hljs">    hilbert_index = encode_hilbert_zero(encoder, cartesian::AbstractVector)
    decode_hilbert_zero!(encoder, cartesian, hilbert_index)</code></pre><p>These are the same as above, but they use zero-based indices. The one-based are a layer on top of these zero-based implementations.</p><h2 id="Example-bit-calculations"><a class="docs-heading-anchor" href="#Example-bit-calculations">Example bit calculations</a><a id="Example-bit-calculations-1"></a><a class="docs-heading-anchor-permalink" href="#Example-bit-calculations" title="Permalink"></a></h2><p>If the Hilbert curve will be in a 32 x 32 space, then the dimension is 2, and it needs <code>log2(32)=5</code> bits of resolution in both directions. For <a href="#BijectiveHilbert.GlobalGray"><code>GlobalGray</code></a>, that&#39;s <code>b=5</code>, <code>n=2</code>. If the sizes aren&#39;t powers of two or are uneven, then set the bits to cover the largest side, so (12 x 12 x 12 x 800) would be <code>b=10</code>, <code>n=4</code> because <span>$800 &lt; 2^{10}$</span>.</p><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><ul><li><a href="#BijectiveHilbert.Bijective.Simple2D"><code>BijectiveHilbert.Bijective.Simple2D</code></a></li><li><a href="#BijectiveHilbert.FaceContinuous"><code>BijectiveHilbert.FaceContinuous</code></a></li><li><a href="#BijectiveHilbert.GlobalGray"><code>BijectiveHilbert.GlobalGray</code></a></li><li><a href="#BijectiveHilbert.SpaceGray"><code>BijectiveHilbert.SpaceGray</code></a></li><li><a href="#BijectiveHilbert.axis_type-Tuple{FaceContinuous}"><code>BijectiveHilbert.axis_type</code></a></li><li><a href="#BijectiveHilbert.decode_hilbert!-Union{Tuple{T}, Tuple{A}, Tuple{BijectiveHilbert.HilbertAlgorithm{T}, AbstractVector{A}, T}} where {A, T}"><code>BijectiveHilbert.decode_hilbert!</code></a></li><li><a href="#BijectiveHilbert.decode_hilbert_zero!-Union{Tuple{T}, Tuple{GlobalGray{T}, AbstractVector, T}} where T"><code>BijectiveHilbert.decode_hilbert_zero!</code></a></li><li><a href="#BijectiveHilbert.encode_hilbert-Union{Tuple{T}, Tuple{A}, Tuple{BijectiveHilbert.HilbertAlgorithm{T}, AbstractVector{A}}} where {A, T}"><code>BijectiveHilbert.encode_hilbert</code></a></li><li><a href="#BijectiveHilbert.encode_hilbert_zero-Union{Tuple{XT}, Tuple{T}, Tuple{GlobalGray{T}, AbstractVector{XT}}} where {T, XT}"><code>BijectiveHilbert.encode_hilbert_zero</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BijectiveHilbert.Bijective.Simple2D" href="#BijectiveHilbert.Bijective.Simple2D"><code>BijectiveHilbert.Bijective.Simple2D</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Simple2D(::Type{T})</p><p>The type is a data type to hold the Hilbert index. It should have enough bits to hold all bits of integer axes to encode.</p><p>The variant algorithm used differs from the usual Hilbert code because it doesn&#39;t need to know the size of the whole grid before computing the code. It looks like a slightly-rotated version of the Hilbert curve, but it has the benefit that it is 1-1 between <code>(x, y)</code> and <code>z</code>, so you can translate back and forth.</p><p>If the size of the axis values or the size of the Hilbert index are too large to be stored in the data types of the axis vector or index, then you&#39;ll see an error from a failure of <code>trunc</code>, which tries to copy values into the smaller datatype. Solve this by using a larger datatype, so UInt64 instead of UInt32.</p><p>It comes from a paper:  N. Chen, N. Wang, B. Shi, A new algorithm for encoding and decoding the Hilbert order. Software—Practice and Experience 2007; 37(8): 897–908.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/8c868eb9e0fbe5e8a65216e259e40ae36c41beea/src/BijectiveHilbert.jl#L22-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BijectiveHilbert.FaceContinuous" href="#BijectiveHilbert.FaceContinuous"><code>BijectiveHilbert.FaceContinuous</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FaceContinuous(b::Int, n::Int)
FaceContinuous(::Type{T}, b::Int, n::Int)</code></pre><p>For <code>n</code> dimensions, use <code>b</code> bits of precision in this Hilbert curve. If you specify a type <code>T</code>, this will be used as the type of the Hilbert encoding. If not, the smallest unsigned integer that can hold <code>n*b</code> bits will be used for the Hilbert index data type.</p><p>This is the Butz algorithm, as presented by Lawder. Haverkort2017 says it is face continuous. The code is in lawder.c. The original paper had an error, and Lawder put a correction on his website. http://www.dcs.bbk.ac.uk/~jkl/publications.html</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/8c868eb9e0fbe5e8a65216e259e40ae36c41beea/src/facecontinuous.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BijectiveHilbert.GlobalGray" href="#BijectiveHilbert.GlobalGray"><code>BijectiveHilbert.GlobalGray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GlobalGray(b, n)
GlobalGray(T, b, n)</code></pre><p><code>T</code> is a data type for the Hilbert index. It can be signed or unsigned, as long as it has at least <code>n * b</code> bits. <code>n</code> is the number of dimensions, and <code>b</code> is the bits per dimension, so each axis value should be between 0 and <span>$2^b - 1$</span>, inclusive, for the zero-based interface. They should be between 1 and <span>$2^b$</span>, inclusive, for the one-based interface.</p><p>The GlobalGray algorithm is an n-dimensional Hilbert curve with a simplified implementation. It follows an article, &quot;Programming the Hilbert Curve,&quot; by John Skilling, 707 (2004), http://dx.doi.org/10.1063/1.1751381. I call it &quot;Global Gray&quot; because the insight of the article is that a single, global Gray code can be applied to all np bits of a Hilbert length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/8c868eb9e0fbe5e8a65216e259e40ae36c41beea/src/global_gray.jl#L123-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BijectiveHilbert.SpaceGray" href="#BijectiveHilbert.SpaceGray"><code>BijectiveHilbert.SpaceGray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpaceGray(b, n)
SpaceGray(::Type{T}, b, n)</code></pre><p>This is an n-dimensional Hilbert curve where all <code>n</code> dimensions must have <code>b</code> bits in size. It was described in the same paper and examples as the <code>Compact</code> algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/8c868eb9e0fbe5e8a65216e259e40ae36c41beea/src/hamilton.jl#L318-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BijectiveHilbert.axis_type-Tuple{FaceContinuous}" href="#BijectiveHilbert.axis_type-Tuple{FaceContinuous}"><code>BijectiveHilbert.axis_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Used during testing to pick a type for the xyz coordinate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/8c868eb9e0fbe5e8a65216e259e40ae36c41beea/src/facecontinuous.jl#L29-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BijectiveHilbert.decode_hilbert!-Union{Tuple{T}, Tuple{A}, Tuple{BijectiveHilbert.HilbertAlgorithm{T}, AbstractVector{A}, T}} where {A, T}" href="#BijectiveHilbert.decode_hilbert!-Union{Tuple{T}, Tuple{A}, Tuple{BijectiveHilbert.HilbertAlgorithm{T}, AbstractVector{A}, T}} where {A, T}"><code>BijectiveHilbert.decode_hilbert!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decode_hilbert!(ha::HilbertAlgorithm{T}, X::Vector{A})</code></pre><p>A 1-based Hilbert decode, from <a href="#BijectiveHilbert.decode_hilbert_zero!-Union{Tuple{T}, Tuple{GlobalGray{T}, AbstractVector, T}} where T"><code>decode_hilbert_zero!</code></a>. Both the Hilbert index and the axes start counting at 1 instead of 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/8c868eb9e0fbe5e8a65216e259e40ae36c41beea/src/hilbert_algorithm.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BijectiveHilbert.decode_hilbert_zero!-Union{Tuple{T}, Tuple{GlobalGray{T}, AbstractVector, T}} where T" href="#BijectiveHilbert.decode_hilbert_zero!-Union{Tuple{T}, Tuple{GlobalGray{T}, AbstractVector, T}} where T"><code>BijectiveHilbert.decode_hilbert_zero!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decode_hilbert_zero!(ha::HilbertAlgorithm{T}}, X::Vector{A}, h::T)</code></pre><p>Given a Hilbert index, <code>h</code>, computes an n-dimensional coordinate <code>X</code>. The type of the Hilbert index is large enought to contain the bits of all dimensions of the axis vector, <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/8c868eb9e0fbe5e8a65216e259e40ae36c41beea/src/global_gray.jl#L180-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BijectiveHilbert.encode_hilbert-Union{Tuple{T}, Tuple{A}, Tuple{BijectiveHilbert.HilbertAlgorithm{T}, AbstractVector{A}}} where {A, T}" href="#BijectiveHilbert.encode_hilbert-Union{Tuple{T}, Tuple{A}, Tuple{BijectiveHilbert.HilbertAlgorithm{T}, AbstractVector{A}}} where {A, T}"><code>BijectiveHilbert.encode_hilbert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">encode_hilbert(ha::HilbertAlgorithm{T}, X::Vector{A})</code></pre><p>A 1-based Hilbert encoding. Both the Hilbert index and the axes start counting at 1 instead of 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/8c868eb9e0fbe5e8a65216e259e40ae36c41beea/src/hilbert_algorithm.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BijectiveHilbert.encode_hilbert_zero-Union{Tuple{XT}, Tuple{T}, Tuple{GlobalGray{T}, AbstractVector{XT}}} where {T, XT}" href="#BijectiveHilbert.encode_hilbert_zero-Union{Tuple{XT}, Tuple{T}, Tuple{GlobalGray{T}, AbstractVector{XT}}} where {T, XT}"><code>BijectiveHilbert.encode_hilbert_zero</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">encode_hilbert_zero(ha::HilbertAlgorithm{T}, X::Vector{A})</code></pre><p>Takes an n-dimensional vector <code>X</code> and returns a single integer of type <code>T</code> which orders <code>X</code> to improve spatial locality. The input <code>X</code> has multiple axes and the output is called a Hilbert index. This version is zero-based, so each axis counts from 0, and the smallest Hilbert index is 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/8c868eb9e0fbe5e8a65216e259e40ae36c41beea/src/global_gray.jl#L166-L173">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../hilbert/">Pseudo-Hilbert Curves for Computational Science »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Monday 14 April 2025 22:46">Monday 14 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
