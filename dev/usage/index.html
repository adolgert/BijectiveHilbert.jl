<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · BijectiveHilbert.jl</title><link rel="canonical" href="https://adolgert.github.io/BijectiveHilbert.jl/usage/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">BijectiveHilbert.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Usage</a><ul class="internal"><li><a class="tocitem" href="#Decide-dimensions-of-the-spatial-axes"><span>Decide dimensions of the spatial axes</span></a></li><li><a class="tocitem" href="#Create-an-algorithm"><span>Create an algorithm</span></a></li><li><a class="tocitem" href="#Encode-and-decode"><span>Encode and decode</span></a></li><li><a class="tocitem" href="#Encode-and-decode-with-a-zero-based-value"><span>Encode and decode with a zero-based value</span></a></li><li class="toplevel"><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><span class="tocitem">Algorithms</span><ul><li><a class="tocitem" href="../hilbert/">Pseudo-Hilbert Curves for Computational Science</a></li><li><a class="tocitem" href="../simple2d/">Simple2D</a></li><li><a class="tocitem" href="../globalgray/">Global Gray</a></li><li><a class="tocitem" href="../compact/">Compact and SpaceGray</a></li><li><a class="tocitem" href="../facecontinuous/">Face Continuous</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/master/docs/src/usage.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h1><p>All of the Hilbert algorithms have the same interface.</p><h2 id="Decide-dimensions-of-the-spatial-axes"><a class="docs-heading-anchor" href="#Decide-dimensions-of-the-spatial-axes">Decide dimensions of the spatial axes</a><a id="Decide-dimensions-of-the-spatial-axes-1"></a><a class="docs-heading-anchor-permalink" href="#Decide-dimensions-of-the-spatial-axes" title="Permalink"></a></h2><p>All of the algorithms, except <a href="#BijectiveHilbert.Bijective.Simple2D"><code>Simple2D</code></a>, need to know ahead of time the extent of the coordinate system. If the Hilbert curve will be in a 32 x 32 space, then the dimension is 2, and it needs <code>log2(32)=5</code> bits of resolution in both directions. For <a href="#BijectiveHilbert.GlobalGray"><code>GlobalGray</code></a>, that&#39;s <code>b=5</code>, <code>n=2</code>. If the sizes aren&#39;t powers of two or are uneven, then set the bits to cover the largest side, so (12 x 12 x 12 x 800) would be <code>b=10</code>, <code>n=4</code> because <span>$800 &lt; 2^{10}$</span>. There is one algorithm that deals better with uneven sides. The <a href="#BijectiveHilbert.Compact"><code>Compact</code></a> algorithm can pack bits together so that the resulting Hilbert index takes less storage space. This is usually used for database storage. It could take (12 x 12 x 12 x 800) as <code>Compact([4, 4, 4, 10])</code> which results in a 24-bit integer that can be stored in a UInt32.</p><h2 id="Create-an-algorithm"><a class="docs-heading-anchor" href="#Create-an-algorithm">Create an algorithm</a><a id="Create-an-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Create-an-algorithm" title="Permalink"></a></h2><p>For most Hilbert curve algorithms, you have to say, beforehand, how large the multidimensional coordinates are, in powers of two. For instance, a three-dimensional grid can have values from 1 to 16 in each dimension, so <code>n = 3</code> and <code>b = 4</code> because <code>16 = 2^b</code>.</p><pre><code class="language-julia">using BijectiveHilbert
dimensions = 3
bits = 4
simple = Simple2D(Int)
gg = GlobalGray(UInt, bits, dimensions)
sg = SpaceGray(UInt, bits, dimensions)
compact = Compact(UInt, fill(bits, dimensions))</code></pre><p>The first argument is a datatype for the Hilbert index. It should be large enough to hold all of the bits from the n-dimensional axes. If you don&#39;t specify one, it will use the smallest unsigned integer that can hold them.</p><p>Note that the <a href="#BijectiveHilbert.Compact"><code>Compact</code></a> algorithm can have different sizes for each dimension, but they are all powers of two. It produces a Hilbert index that uses only as many bits as necessary.</p><h2 id="Encode-and-decode"><a class="docs-heading-anchor" href="#Encode-and-decode">Encode and decode</a><a id="Encode-and-decode-1"></a><a class="docs-heading-anchor-permalink" href="#Encode-and-decode" title="Permalink"></a></h2><p>You can encode from n-dimensions to the Hilbert index, or you can decode from a Hilbert index to n-dimensions.</p><pre><code class="language-julia">for algorithm in [simple, gg, sg, compact]
    for k in 1:(1&lt;&lt;bits)
        for j in 1:(1&lt;&lt;bits)
            for i in 1:(1&lt;&lt;bits)
                X = [i, j, k]
                h = encode_hilbert(algorithm, X)
                X .= 0
                decode_hilbert!(algorithm, X, h)
            end
        end
    end
end</code></pre><h2 id="Encode-and-decode-with-a-zero-based-value"><a class="docs-heading-anchor" href="#Encode-and-decode-with-a-zero-based-value">Encode and decode with a zero-based value</a><a id="Encode-and-decode-with-a-zero-based-value-1"></a><a class="docs-heading-anchor-permalink" href="#Encode-and-decode-with-a-zero-based-value" title="Permalink"></a></h2><p>The underlying algorithms use a zero-based axis and a zero-based Hilbert index. These are available, too.</p><pre><code class="language-julia">for algorithm in [simple, gg, sg, compact]
    for k in 0:(1&lt;&lt;bits - 1)
        for j in 0:(1&lt;&lt;bits - 1)
            for i in 0:(1&lt;&lt;bits - 1)
                X = [i, j, k]
                h = encode_hilbert_zero(algorithm, X)
                X .= 0
                decode_hilbert_zero!(algorithm, X, h)
            end
        end
    end
end</code></pre><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><ul><li><a href="#BijectiveHilbert.Bijective.Simple2D"><code>BijectiveHilbert.Bijective.Simple2D</code></a></li><li><a href="#BijectiveHilbert.Compact"><code>BijectiveHilbert.Compact</code></a></li><li><a href="#BijectiveHilbert.FaceContinuous"><code>BijectiveHilbert.FaceContinuous</code></a></li><li><a href="#BijectiveHilbert.GlobalGray"><code>BijectiveHilbert.GlobalGray</code></a></li><li><a href="#BijectiveHilbert.SpaceGray"><code>BijectiveHilbert.SpaceGray</code></a></li><li><a href="#BijectiveHilbert.axis_type-Tuple{FaceContinuous}"><code>BijectiveHilbert.axis_type</code></a></li><li><a href="#BijectiveHilbert.decode_hilbert!-Union{Tuple{T}, Tuple{A}, Tuple{BijectiveHilbert.HilbertAlgorithm{T}, Vector{A}, T}} where {A, T}"><code>BijectiveHilbert.decode_hilbert!</code></a></li><li><a href="#BijectiveHilbert.decode_hilbert_zero!-Union{Tuple{T}, Tuple{GlobalGray{T}, Vector, T}} where T"><code>BijectiveHilbert.decode_hilbert_zero!</code></a></li><li><a href="#BijectiveHilbert.encode_hilbert-Union{Tuple{T}, Tuple{A}, Tuple{BijectiveHilbert.HilbertAlgorithm{T}, Vector{A}}} where {A, T}"><code>BijectiveHilbert.encode_hilbert</code></a></li><li><a href="#BijectiveHilbert.encode_hilbert_zero-Union{Tuple{T}, Tuple{GlobalGray{T}, Vector}} where T"><code>BijectiveHilbert.encode_hilbert_zero</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="BijectiveHilbert.Bijective.Simple2D" href="#BijectiveHilbert.Bijective.Simple2D"><code>BijectiveHilbert.Bijective.Simple2D</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Simple2D(::Type{T})</p><p>The type is a data type to hold the Hilbert index. It should have enough bits to hold all bits of integer axes to encode.</p><p>The variant algorithm used differs from the usual Hilbert code because it doesn&#39;t need to know the size of the whole grid before computing the code. It looks like a slightly-rotated version of the Hilbert curve, but it has the benefit that it is 1-1 between <code>(x, y)</code> and <code>z</code>, so you can translate back and forth.</p><p>If the size of the axis values or the size of the Hilbert index are too large to be stored in the data types of the axis vector or index, then you&#39;ll see an error from a failure of <code>trunc</code>, which tries to copy values into the smaller datatype. Solve this by using a larger datatype, so UInt64 instead of UInt32.</p><p>It comes from a paper:  N. Chen, N. Wang, B. Shi, A new algorithm for encoding and decoding the Hilbert order. Software—Practice and Experience 2007; 37(8): 897–908.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fd177f95bfcac055a4fe967dd399f487045432a2/src/BijectiveHilbert.jl#LL24-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BijectiveHilbert.Compact" href="#BijectiveHilbert.Compact"><code>BijectiveHilbert.Compact</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Compact(ms::Vector{Int})
Compact(::Type{T}, ms::Vector{Int})</code></pre><p>This algorithm is n-dimensional and permits dimensions to use different numbers of bits, specified in the <code>ms</code> vector. The type <code>T</code> is an optional data type for the Hilbert index. It should be greater than or equal to the sum of the bits.</p><p>This algorithm comes from three sources:</p><ul><li><p>A technical report, &quot;Compact Hilbert Indices&quot; by Chris Hamilton. Technical Report CS-2006-07. 6059 University Ave., Halifax, Nova Scotia, B3H 1W5, Canada. This report is informative but has many errors.</p></li><li><p>A paper by Hamilton and Rau-Chaplin, &quot;Compact Hilbert Indices for Multi-Dimensional Data,&quot; 2007. Nice paper. Also wrong.</p></li><li><p>The <a href="https://github.com/pdebuyl/libhilbert">libhilbert source code</a> is a copy of Hamilton&#39;s work and has many corrections. This, ultimately, lead to the working code.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fd177f95bfcac055a4fe967dd399f487045432a2/src/hamilton.jl#LL431-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BijectiveHilbert.FaceContinuous" href="#BijectiveHilbert.FaceContinuous"><code>BijectiveHilbert.FaceContinuous</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FaceContinuous(b::Int, n::Int)
FaceContinuous(::Type{T}, b::Int, n::Int)</code></pre><p>For <code>n</code> dimensions, use <code>b</code> bits of precision in this Hilbert curve. If you specify a type <code>T</code>, this will be used as the type of the Hilbert encoding. If not, the smallest unsigned integer that can hold <code>n*b</code> bits will be used for the Hilbert index data type.</p><p>This is the Butz algorithm, as presented by Lawder. Haverkort2017 says it is face continuous. The code is in lawder.c. The original paper had an error, and Lawder put a correction on his website. http://www.dcs.bbk.ac.uk/~jkl/publications.html</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fd177f95bfcac055a4fe967dd399f487045432a2/src/facecontinuous.jl#LL1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BijectiveHilbert.GlobalGray" href="#BijectiveHilbert.GlobalGray"><code>BijectiveHilbert.GlobalGray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GlobalGray(b, n)
GlobalGray(T, b, n)</code></pre><p><code>T</code> is a data type for the Hilbert index. It can be signed or unsigned, as long as it has at least <code>n * b</code> bits. <code>n</code> is the number of dimensions, and <code>b</code> is the bits per dimension, so each axis value should be between 0 and <span>$2^b - 1$</span>, inclusive, for the zero-based interface. They should be between 1 and <span>$2^b$</span>, inclusive, for the one-based interface.</p><p>The GlobalGray algorithm is an n-dimensional Hilbert curve with a simplified implementation. It follows an article, &quot;Programming the Hilbert Curve,&quot; by John Skilling, 707 (2004), http://dx.doi.org/10.1063/1.1751381. I call it &quot;Global Gray&quot; because the insight of the article is that a single, global Gray code can be applied to all np bits of a Hilbert length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fd177f95bfcac055a4fe967dd399f487045432a2/src/global_gray.jl#LL123-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BijectiveHilbert.SpaceGray" href="#BijectiveHilbert.SpaceGray"><code>BijectiveHilbert.SpaceGray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SpaceGray(b, n)
SpaceGray(::Type{T}, b, n)</code></pre><p>This is an n-dimensional Hilbert curve where all <code>n</code> dimensions must have <code>b</code> bits in size. It was described in the same paper and examples as the <code>Compact</code> algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fd177f95bfcac055a4fe967dd399f487045432a2/src/hamilton.jl#LL393-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BijectiveHilbert.axis_type-Tuple{FaceContinuous}" href="#BijectiveHilbert.axis_type-Tuple{FaceContinuous}"><code>BijectiveHilbert.axis_type</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Used during testing to pick a type for the xyz coordinate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fd177f95bfcac055a4fe967dd399f487045432a2/src/facecontinuous.jl#LL29-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BijectiveHilbert.decode_hilbert!-Union{Tuple{T}, Tuple{A}, Tuple{BijectiveHilbert.HilbertAlgorithm{T}, Vector{A}, T}} where {A, T}" href="#BijectiveHilbert.decode_hilbert!-Union{Tuple{T}, Tuple{A}, Tuple{BijectiveHilbert.HilbertAlgorithm{T}, Vector{A}, T}} where {A, T}"><code>BijectiveHilbert.decode_hilbert!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decode_hilbert!(ha::HilbertAlgorithm{T}, X::Vector{A})</code></pre><p>A 1-based Hilbert decode, from <a href="#BijectiveHilbert.decode_hilbert_zero!-Union{Tuple{T}, Tuple{GlobalGray{T}, Vector, T}} where T"><code>decode_hilbert_zero!</code></a>. Both the Hilbert index and the axes start counting at 1 instead of 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fd177f95bfcac055a4fe967dd399f487045432a2/src/hilbert_algorithm.jl#LL19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BijectiveHilbert.decode_hilbert_zero!-Union{Tuple{T}, Tuple{GlobalGray{T}, Vector, T}} where T" href="#BijectiveHilbert.decode_hilbert_zero!-Union{Tuple{T}, Tuple{GlobalGray{T}, Vector, T}} where T"><code>BijectiveHilbert.decode_hilbert_zero!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decode_hilbert_zero!(ha::HilbertAlgorithm{T}}, X::Vector{A}, h::T)</code></pre><p>Given a Hilbert index, <code>h</code>, computes an n-dimensional coordinate <code>X</code>. The type of the Hilbert index is large enought to contain the bits of all dimensions of the axis vector, <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fd177f95bfcac055a4fe967dd399f487045432a2/src/global_gray.jl#LL180-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BijectiveHilbert.encode_hilbert-Union{Tuple{T}, Tuple{A}, Tuple{BijectiveHilbert.HilbertAlgorithm{T}, Vector{A}}} where {A, T}" href="#BijectiveHilbert.encode_hilbert-Union{Tuple{T}, Tuple{A}, Tuple{BijectiveHilbert.HilbertAlgorithm{T}, Vector{A}}} where {A, T}"><code>BijectiveHilbert.encode_hilbert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">encode_hilbert(ha::HilbertAlgorithm{T}, X::Vector{A})</code></pre><p>A 1-based Hilbert encoding. Both the Hilbert index and the axes start counting at 1 instead of 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fd177f95bfcac055a4fe967dd399f487045432a2/src/hilbert_algorithm.jl#LL8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BijectiveHilbert.encode_hilbert_zero-Union{Tuple{T}, Tuple{GlobalGray{T}, Vector}} where T" href="#BijectiveHilbert.encode_hilbert_zero-Union{Tuple{T}, Tuple{GlobalGray{T}, Vector}} where T"><code>BijectiveHilbert.encode_hilbert_zero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">encode_hilbert_zero(ha::HilbertAlgorithm{T}, X::Vector{A})</code></pre><p>Takes an n-dimensional vector <code>X</code> and returns a single integer of type <code>T</code> which orders <code>X</code> to improve spatial locality. The input <code>X</code> has multiple axes and the output is called a Hilbert index. This version is zero-based, so each axis counts from 0, and the smallest Hilbert index is 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/adolgert/BijectiveHilbert.jl/blob/fd177f95bfcac055a4fe967dd399f487045432a2/src/global_gray.jl#LL166-L173">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../hilbert/">Pseudo-Hilbert Curves for Computational Science »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 6 February 2022 14:46">Sunday 6 February 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
