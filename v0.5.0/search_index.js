var documenterSearchIndex = {"docs":
[{"location":"globalgray/#Global-Gray","page":"Global Gray","title":"Global Gray","text":"","category":"section"},{"location":"globalgray/","page":"Global Gray","title":"Global Gray","text":"See the Usage.","category":"page"},{"location":"globalgray/","page":"Global Gray","title":"Global Gray","text":"This is a very concise algorithm for Hilbert curve generation. It works in n-dimensions. It requires little code. It comes from a little paper [1] behind a paywall, sadly.","category":"page"},{"location":"globalgray/","page":"Global Gray","title":"Global Gray","text":"Most algorithms for the Hilbert curve use Gray codes to generate the shape. He observed that, instead of using the space key algorithm, which dives to each level deeper and rotates the Gray code, the algorithm could use a global transformation of all values with a Gray code and then do a minor fix-up, afterwards, so untwist it. The resulting code is much simpler than earlier efforts.","category":"page"},{"location":"globalgray/","page":"Global Gray","title":"Global Gray","text":"For developers, note that this algorithm relies on encoding the Hilbert index in what, to me, was a surprising order. To understand the interleaving of the Hilbert index for this algorithm, start with a 2D value where higher bits are larger subscripts, (a_4a_3a_2a_1 b_4b_3b_2b_1). Skilling encodes this as a_4b_4a_3b_3a_2b_2a_1b_1, which looks good on paper, but it means the first element of the vector has the higher bits.","category":"page"},{"location":"globalgray/","page":"Global Gray","title":"Global Gray","text":"[1]: Skilling, John. \"Programming the Hilbert curve.\" AIP Conference Proceedings. Vol. 707. No. 1. American Institute of Physics, 2004.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"CurrentModule = BijectiveHilbert","category":"page"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/#Create-an-encoder","page":"Usage","title":"Create an encoder","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"    simple = Simple2D(HilbertType)\n    sg = SpaceGray(HilbertType, bits, dimensions)\n    gg = GlobalGray(HilbertType, bits, dimensions)\n    sg = FaceContinuous(HilbertType, bits, dimensions)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"HilbertType is an unsigned integer DataType large enough to hold the HilbertIndex. The returned HilbertIndex will have this type. Examples are UInt32 and UInt128.\nbits is the maximum bit width of a DataType that can hold the Cartesian index in each dimension. If bits is 7, that means all indices are between 1 and 128=2^7 or between 0 and 127=2^7-1.\ndimension is the integer number of Cartesian dimensions.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Simple2D doesn't need to know dimensions ahead of time.","category":"page"},{"location":"usage/#Encode-and-Decode","page":"Usage","title":"Encode and Decode","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"    hilbert_index = encode_hilbert(encoder, cartesian::AbstractVector)\n    decode_hilbert!(encoder, cartesian, hilbert_index)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"This converts from Cartesian indices in a vector to an integer Hilbert index. Then it converts back to Cartesian. decoding overwrites the cartesian array values. The input Cartesian vector may have any AbstractVector type. It can be faster if you use a StaticArrays.MVector of fixed size.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"    hilbert_index = encode_hilbert_zero(encoder, cartesian::AbstractVector)\n    decode_hilbert_zero!(encoder, cartesian, hilbert_index)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"These are the same as above, but they use zero-based indices. The one-based are a layer on top of these zero-based implementations.","category":"page"},{"location":"usage/#Example-bit-calculations","page":"Usage","title":"Example bit calculations","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"If the Hilbert curve will be in a 32 x 32 space, then the dimension is 2, and it needs log2(32)=5 bits of resolution in both directions. For GlobalGray, that's b=5, n=2. If the sizes aren't powers of two or are uneven, then set the bits to cover the largest side, so (12 x 12 x 12 x 800) would be b=10, n=4 because 800  2^10.","category":"page"},{"location":"usage/#Index","page":"Usage","title":"Index","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Modules = [BijectiveHilbert]\nPrivate = false","category":"page"},{"location":"usage/#BijectiveHilbert.Bijective.Simple2D","page":"Usage","title":"BijectiveHilbert.Bijective.Simple2D","text":"Simple2D(::Type{T})\n\nThe type is a data type to hold the Hilbert index. It should have enough bits to hold all bits of integer axes to encode.\n\nThe variant algorithm used differs from the usual Hilbert code because it doesn't need to know the size of the whole grid before computing the code. It looks like a slightly-rotated version of the Hilbert curve, but it has the benefit that it is 1-1 between (x, y) and z, so you can translate back and forth.\n\nIf the size of the axis values or the size of the Hilbert index are too large to be stored in the data types of the axis vector or index, then you'll see an error from a failure of trunc, which tries to copy values into the smaller datatype. Solve this by using a larger datatype, so UInt64 instead of UInt32.\n\nIt comes from a paper:  N. Chen, N. Wang, B. Shi, A new algorithm for encoding and decoding the Hilbert order. Software—Practice and Experience 2007; 37(8): 897–908.\n\n\n\n\n\n","category":"type"},{"location":"usage/#BijectiveHilbert.FaceContinuous","page":"Usage","title":"BijectiveHilbert.FaceContinuous","text":"FaceContinuous(b::Int, n::Int)\nFaceContinuous(::Type{T}, b::Int, n::Int)\n\nFor n dimensions, use b bits of precision in this Hilbert curve. If you specify a type T, this will be used as the type of the Hilbert encoding. If not, the smallest unsigned integer that can hold n*b bits will be used for the Hilbert index data type.\n\nThis is the Butz algorithm, as presented by Lawder. Haverkort2017 says it is face continuous. The code is in lawder.c. The original paper had an error, and Lawder put a correction on his website. http://www.dcs.bbk.ac.uk/~jkl/publications.html\n\n\n\n\n\n","category":"type"},{"location":"usage/#BijectiveHilbert.GlobalGray","page":"Usage","title":"BijectiveHilbert.GlobalGray","text":"GlobalGray(b, n)\nGlobalGray(T, b, n)\n\nT is a data type for the Hilbert index. It can be signed or unsigned, as long as it has at least n * b bits. n is the number of dimensions, and b is the bits per dimension, so each axis value should be between 0 and 2^b - 1, inclusive, for the zero-based interface. They should be between 1 and 2^b, inclusive, for the one-based interface.\n\nThe GlobalGray algorithm is an n-dimensional Hilbert curve with a simplified implementation. It follows an article, \"Programming the Hilbert Curve,\" by John Skilling, 707 (2004), http://dx.doi.org/10.1063/1.1751381. I call it \"Global Gray\" because the insight of the article is that a single, global Gray code can be applied to all np bits of a Hilbert length.\n\n\n\n\n\n","category":"type"},{"location":"usage/#BijectiveHilbert.SpaceGray","page":"Usage","title":"BijectiveHilbert.SpaceGray","text":"SpaceGray(b, n)\nSpaceGray(::Type{T}, b, n)\n\nThis is an n-dimensional Hilbert curve where all n dimensions must have b bits in size. It was described in the same paper and examples as the Compact algorithm.\n\n\n\n\n\n","category":"type"},{"location":"usage/#BijectiveHilbert.axis_type-Tuple{FaceContinuous}","page":"Usage","title":"BijectiveHilbert.axis_type","text":"Used during testing to pick a type for the xyz coordinate.\n\n\n\n\n\n","category":"method"},{"location":"usage/#BijectiveHilbert.decode_hilbert!-Union{Tuple{T}, Tuple{A}, Tuple{BijectiveHilbert.HilbertAlgorithm{T}, AbstractVector{A}, T}} where {A, T}","page":"Usage","title":"BijectiveHilbert.decode_hilbert!","text":"decode_hilbert!(ha::HilbertAlgorithm{T}, X::Vector{A})\n\nA 1-based Hilbert decode, from decode_hilbert_zero!. Both the Hilbert index and the axes start counting at 1 instead of 0.\n\n\n\n\n\n","category":"method"},{"location":"usage/#BijectiveHilbert.decode_hilbert_zero!-Union{Tuple{T}, Tuple{GlobalGray{T}, AbstractVector, T}} where T","page":"Usage","title":"BijectiveHilbert.decode_hilbert_zero!","text":"decode_hilbert_zero!(ha::HilbertAlgorithm{T}}, X::Vector{A}, h::T)\n\nGiven a Hilbert index, h, computes an n-dimensional coordinate X. The type of the Hilbert index is large enought to contain the bits of all dimensions of the axis vector, X.\n\n\n\n\n\n","category":"method"},{"location":"usage/#BijectiveHilbert.encode_hilbert-Union{Tuple{T}, Tuple{A}, Tuple{BijectiveHilbert.HilbertAlgorithm{T}, AbstractVector{A}}} where {A, T}","page":"Usage","title":"BijectiveHilbert.encode_hilbert","text":"encode_hilbert(ha::HilbertAlgorithm{T}, X::Vector{A})\n\nA 1-based Hilbert encoding. Both the Hilbert index and the axes start counting at 1 instead of 0.\n\n\n\n\n\n","category":"method"},{"location":"usage/#BijectiveHilbert.encode_hilbert_zero-Union{Tuple{XT}, Tuple{T}, Tuple{GlobalGray{T}, AbstractVector{XT}}} where {T, XT}","page":"Usage","title":"BijectiveHilbert.encode_hilbert_zero","text":"encode_hilbert_zero(ha::HilbertAlgorithm{T}, X::Vector{A})\n\nTakes an n-dimensional vector X and returns a single integer of type T which orders X to improve spatial locality. The input X has multiple axes and the output is called a Hilbert index. This version is zero-based, so each axis counts from 0, and the smallest Hilbert index is 0.\n\n\n\n\n\n","category":"method"},{"location":"simple2d/#Simple2D","page":"Simple2D","title":"Simple2D","text":"","category":"section"},{"location":"simple2d/","page":"Simple2D","title":"Simple2D","text":"See the Usage.","category":"page"},{"location":"simple2d/","page":"Simple2D","title":"Simple2D","text":"If you want to sort some axes, then this Hilbert curve algorithm is the easiest to use. It doesn't need to know ahead of time how many bits it will need to generate a Hilbert index [1]. As the length along each spatial axis grows, it creates gradually larger Hilbert indices to match it.","category":"page"},{"location":"simple2d/","page":"Simple2D","title":"Simple2D","text":"All of the algorithms use slightly different Hilbert curves. This one uses an asymmetric curve that shifts so that its endpoint is always an outside corder of each 2^n x 2^n tile. The next outer layer builds on the last.","category":"page"},{"location":"simple2d/","page":"Simple2D","title":"Simple2D","text":"[1]: Chen, Ningtau; Wang, Nengchao; Shi, Baochang, \"A new algorithm for encoding and decoding the Hilbert order,\" in Software–-Practice and Experience, 2007, 37, 897-908.","category":"page"},{"location":"facecontinuous/#Face-Continuous","page":"Face Continuous","title":"Face Continuous","text":"","category":"section"},{"location":"facecontinuous/","page":"Face Continuous","title":"Face Continuous","text":"See the Usage.","category":"page"},{"location":"facecontinuous/","page":"Face Continuous","title":"Face Continuous","text":"This is the OG Hilbert code, where the first implementation of encoding came from a paper by Butz [1] and, later, Lawder [2] provided the decoding algorithm. It's called FaceContinuous because that was its main cited property in a review of Hilbert curves [3].","category":"page"},{"location":"facecontinuous/","page":"Face Continuous","title":"Face Continuous","text":"For developers, there are two errors in the code that Lawder corrected. The first is that there is a single-bit mask, called mask, that should be initialized from the number of levels, not from the size of the data type. This is true for both encoding and decoding. The second is that, during decoding, the first assignment, to the highest bit of the coordinates, assigns directly from P, the highest Hilbert index bits. It should assign from A, which is the binary-reflected Gray code of the highest bits. These problems wouldn't show up in testing unless the highest bits in the type were used, which is an understandable oversight.","category":"page"},{"location":"facecontinuous/","page":"Face Continuous","title":"Face Continuous","text":"[1]: Butz, Arthur R. \"Alternative algorithm for Hilbert's space-filling curve.\" IEEE Transactions on Computers 100.4 (1971): 424-426.","category":"page"},{"location":"facecontinuous/","page":"Face Continuous","title":"Face Continuous","text":"[2]: Lawder, Jonathan K. \"Calculation of mappings between one and n-dimensional values using the hilbert space-filling curve.\" School of Computer Science and Information Systems, Birkbeck College, University of London, London Research Report BBKCS-00-01 August (2000).","category":"page"},{"location":"facecontinuous/","page":"Face Continuous","title":"Face Continuous","text":"[3]: Haverkort, Herman. \"Sixteen space-filling curves and traversals for d-dimensional cubes and simplices.\" arXiv preprint arXiv:1711.04473 (2017).","category":"page"},{"location":"compact/#SpaceGray-and-Compact","page":"SpaceGray and Compact","title":"SpaceGray and Compact","text":"","category":"section"},{"location":"compact/","page":"SpaceGray and Compact","title":"SpaceGray and Compact","text":"See the Usage.","category":"page"},{"location":"compact/#SpaceGray","page":"SpaceGray and Compact","title":"SpaceGray","text":"","category":"section"},{"location":"compact/","page":"SpaceGray and Compact","title":"SpaceGray and Compact","text":"The SpaceGray algorithm is the fastest way to generate multi-dimensional Hilbert curves. This library implements a classic space key algorithm that relies on Gray codes. It's not recursive. It follows four steps. Quoting the source paper [1]:","category":"page"},{"location":"compact/","page":"SpaceGray and Compact","title":"SpaceGray and Compact","text":"Find the cell containing the point of interest.\nUpdate the key (index) value appropriately.\nTransform as necessary; and\nContinue until sufficient precision has been obtained.","category":"page"},{"location":"compact/#Compact","page":"SpaceGray and Compact","title":"Compact","text":"","category":"section"},{"location":"compact/","page":"SpaceGray and Compact","title":"SpaceGray and Compact","text":"The Compact algorithm was the star of this library, but every implementation I can find or make is broken, so I've removed it from the interface, but the papers and code are still there if someone knows better.","category":"page"},{"location":"compact/","page":"SpaceGray and Compact","title":"SpaceGray and Compact","text":"This algorithm can encode Hilbert indices for Cartesian domains that aren't square. This is very helpful for skewed coordinate systems.","category":"page"},{"location":"compact/","page":"SpaceGray and Compact","title":"SpaceGray and Compact","text":"As a note for developers, Hamilton's original tech report [2] has errors that look, to me, like he developed the work for two dimensions and expanded it, incompletely, for n dimensions. It's impressively-detailed math that leads to a concise formulation. Hamilton posted corrections to the article's code, Hamilton's code, but these seem to fail my unit tests, as well.","category":"page"},{"location":"compact/","page":"SpaceGray and Compact","title":"SpaceGray and Compact","text":"[1]: Hamilton, Chris H., and Andrew Rau-Chaplin. \"Compact Hilbert indices for multi-dimensional data.\" First International Conference on Complex, Intelligent and Software Intensive Systems (CISIS'07). IEEE, 2007.","category":"page"},{"location":"compact/","page":"SpaceGray and Compact","title":"SpaceGray and Compact","text":"[2]: Hamilton, Chris. \"Compact hilbert indices.\" Dalhousie University, Faculty of Computer Science, Technical Report CS-2006-07 (2006).","category":"page"},{"location":"hilbert/#Pseudo-Hilbert-Curves-for-Computational-Science","page":"Pseudo-Hilbert Curves for Computational Science","title":"Pseudo-Hilbert Curves for Computational Science","text":"","category":"section"},{"location":"hilbert/#Introduction","page":"Pseudo-Hilbert Curves for Computational Science","title":"Introduction","text":"","category":"section"},{"location":"hilbert/","page":"Pseudo-Hilbert Curves for Computational Science","title":"Pseudo-Hilbert Curves for Computational Science","text":"The Pseudo-Hilbert curve sorts regular arrays of points into a linear order that keeps nearby points in the array close to each other in the linear order. Scientific computing algorithms use this capability in a few ways.","category":"page"},{"location":"hilbert/","page":"Pseudo-Hilbert Curves for Computational Science","title":"Pseudo-Hilbert Curves for Computational Science","text":"An easy form of clustering.\nSpeed up queries for databases.\nAllocate work for distributed computing.\nVisualize correlation of large one-dimensional datasets.\nVisualize change over time of two-dimensional datasets.\nApply a one-dimensional global optimization algorithm to a multi-dimensional dataset.\nAn R-tree algorithm that uses Hilbert curves to pick node locations.","category":"page"},{"location":"hilbert/","page":"Pseudo-Hilbert Curves for Computational Science","title":"Pseudo-Hilbert Curves for Computational Science","text":"These widely different applications all use the Hilbert curve, not for drawing, but to convert indices from multiple dimensions to a single dimension and to convert them back to multiple dimensions, as needed. For high performance computing, it's not a drawn curve but an algorithm.","category":"page"},{"location":"hilbert/#The-algorithm","page":"Pseudo-Hilbert Curves for Computational Science","title":"The algorithm","text":"","category":"section"},{"location":"hilbert/","page":"Pseudo-Hilbert Curves for Computational Science","title":"Pseudo-Hilbert Curves for Computational Science","text":"There are two functions. One accepts an array of natural numbers as input and returns a single Hilbert index as output. We call that encoding. The other function decodes the single Hilbert index into the original natural numbers. There are a lot of pairs of functions that can do this.","category":"page"},{"location":"hilbert/","page":"Pseudo-Hilbert Curves for Computational Science","title":"Pseudo-Hilbert Curves for Computational Science","text":"For instance, you may recall from your earliest math class that we use such a pair of functions to prove that the number of integers in the first quadrant of a two-dimensional graph are countably infinite. Starting from (0, 0), move to (0, 1) and then (1, 0). Then move from (2, 0) to (1, 1) to (0, 2). This weaves along diagonals (in boustrophedon order), sweeping out a one-dimensional covering of two dimensions. Each point in 2D has a corresponding, countable point in 1D. Nor is this the only example, by far.","category":"page"},{"location":"hilbert/","page":"Pseudo-Hilbert Curves for Computational Science","title":"Pseudo-Hilbert Curves for Computational Science","text":"Julia stores its matrices in column-major order. C stores its matrices in row-major order. Both are orderings of two-dimensional rectangles according to a linear storage order. So, too, is block storage of data. These are functions like the Hilbert curve because we can automatically translate from (i, j) to a single index in memory, if we know the dimensions of the matrix.","category":"page"},{"location":"hilbert/","page":"Pseudo-Hilbert Curves for Computational Science","title":"Pseudo-Hilbert Curves for Computational Science","text":"The Hilbert algorithm is equivalent to the use of column-major order with one addition. Two points near each other according to the Hilbert index will tend to be closer to each other if we measure the Euclidean distance between their two-dimensional indices. There isn't a guaranteed upper bound on how far apart two points can be, but experiments comparing nearness, called spatial locality, confirm that the Hilbert curve tends to arrange points closer to each other than does column-major storage, block storage, or other self-similar space-filling curves, such as the Peano curve.","category":"page"},{"location":"hilbert/","page":"Pseudo-Hilbert Curves for Computational Science","title":"Pseudo-Hilbert Curves for Computational Science","text":"That's why this algorithm is useful. Given a bunch of (i, j) indices, the Hilbert index helps to arrange them in a single vector such that nearby indices tend to be closer to each other. Using a Hilbert algorithm can be a little more complicated than that, only because tradition asks that you focus on counts of bits. Let's look at why this is an easy, if important, requirement.","category":"page"},{"location":"hilbert/#Counting-bits","page":"Pseudo-Hilbert Curves for Computational Science","title":"Counting bits","text":"","category":"section"},{"location":"hilbert/","page":"Pseudo-Hilbert Curves for Computational Science","title":"Pseudo-Hilbert Curves for Computational Science","text":"Like a column-major order for a matrix, a Hilbert algorithm needs to know, before doing a conversion, what extent the data might have. Most implementations of Hilbert curves assume that every dimension of the input coordinates will have the same size and will be a power of two. If your data is 25 x 38, that means you need a 64 x 64 grid on which to work. That means the i-axis requires 6 bits and the j-axis requires 6-bits. As a result, the Hilbert index will run from 0 to 4095, needing 12-bits in which to store its result.","category":"page"},{"location":"hilbert/","page":"Pseudo-Hilbert Curves for Computational Science","title":"Pseudo-Hilbert Curves for Computational Science","text":"If we don't use the full size of the allocated axes, are we not going to get as good spatial locality from the Hilbert curve? This is only approximate to start with. The way to use this algorithm is to create axes that are large enough and not worry about the unused bits of information.","category":"page"},{"location":"hilbert/","page":"Pseudo-Hilbert Curves for Computational Science","title":"Pseudo-Hilbert Curves for Computational Science","text":"The bit count matters for choosing types of function arguments. It's usually easy for the coordinates to hold their integer data, but higher dimensions can make the resulting Hilbert index too large for most data types. Eight dimensions of ten bits is 80 bits, which exceeds a typical Int64. That's fine in Julia, which has both Int128 and BigInt types. In addition, most of the math is defined for unsigned integers, but the algorithms in this library are tested to work up to the last sign-bit for signed integers, so they are OK to use.","category":"page"},{"location":"hilbert/#Properties-of-different-Hilbert-curves","page":"Pseudo-Hilbert Curves for Computational Science","title":"Properties of different Hilbert curves","text":"","category":"section"},{"location":"hilbert/","page":"Pseudo-Hilbert Curves for Computational Science","title":"Pseudo-Hilbert Curves for Computational Science","text":"There are multiple Hilbert curves. There is even a paper called, \"How many three-dimensional Hilbert curves are there?\" by Haverkort (2017). The different curves have different orientataions relative to their axes. They can be symmetric or asymmetric. They fill space in slightly different ways, (almost) all of which require domains that are powers of two in each direction. Haverkort also wrote a lovely paper describing these differences, in \"Sixteen space-filling curves and traversals for d-dimensional cubes and simplices.\"","category":"page"},{"location":"hilbert/","page":"Pseudo-Hilbert Curves for Computational Science","title":"Pseudo-Hilbert Curves for Computational Science","text":"For use in scientific computing, it may be more important to judge different Hilbert curve algorithms on capability, speed, and relaxation of constraints.","category":"page"},{"location":"hilbert/","page":"Pseudo-Hilbert Curves for Computational Science","title":"Pseudo-Hilbert Curves for Computational Science","text":"The Simple2D algorithm doesn't need to know how large the axes may be before you use it, but it only works in 2D.\nThe GlobalGray algorithm is fast for an n-dimensional algorithm.\nThe FaceContinuous algorithm is slower and is included because it has a different shape and is historically important as the first non-recursive n-dimensional algorithm.","category":"page"},{"location":"hilbert/","page":"Pseudo-Hilbert Curves for Computational Science","title":"Pseudo-Hilbert Curves for Computational Science","text":"In general, algorithms that are written explicitly for 2D are faster than n-dimensional equivalents.","category":"page"},{"location":"hilbert/#Other-work-around-Hilbert-curves","page":"Pseudo-Hilbert Curves for Computational Science","title":"Other work around Hilbert curves","text":"","category":"section"},{"location":"hilbert/","page":"Pseudo-Hilbert Curves for Computational Science","title":"Pseudo-Hilbert Curves for Computational Science","text":"This library provides two functions for each algorithm, one to encode and one to decode. There is considerable work around making more-efficient queries of data stored in Hilbert order. These algorithms take a single Hilbert index and return the Hilbert index in any coordinate direction. They don't need to convert to coordinates, find the neighbor in that space, and convert back to the Hilbert index. There is also work to make rectangular queries faster, in general. These find sequences of Hilbert indexes that fall within a rectangular region in coordinate space.","category":"page"},{"location":"hilbert/","page":"Pseudo-Hilbert Curves for Computational Science","title":"Pseudo-Hilbert Curves for Computational Science","text":"None of those are implemented here. They would be useful for advanced database work.","category":"page"},{"location":"#BijectiveHilbert","page":"Home","title":"BijectiveHilbert","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Hilbert curve library encodes a multi-dimensional grid index into a single integer, such that nearby integers are nearby grid indices. See the Usage.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"BijectiveHilbert\")\njulia> using BijectiveHilbert\njulia> xy_coordinates = zeros(Int, 8, 8)\njulia> for y in 1:size(xy_coordinates, 2)\n           for x in 1:size(xy_coordinates, 1)\n               z = encode_hilbert(Simple2D(Int), [x, y])\n               xy_coordinates[x, y] = z\n           end\n       end\njulia> xy_coordinates\n8×8 Array{Int64,2}:\n  1   2  15  16  17  20  21  22\n  4   3  14  13  18  19  24  23\n  5   8   9  12  31  30  25  26\n  6   7  10  11  32  29  28  27\n 59  58  55  54  33  36  37  38\n 60  57  56  53  34  35  40  39\n 61  62  51  52  47  46  41  42\n 64  63  50  49  48  45  44  43\njulia> X = zeros(Int, 2)\njulia> decode_hilbert!(Simple2D(Int), X, xy_coordinates[5, 7])\njulia> X == [5, 7]","category":"page"},{"location":"","page":"Home","title":"Home","text":"This function, called a Hilbert curve, is used most often for geospatial work or database implementation but is equally appropriate for dealing with large TIFF files. It belongs to the class of space-filling, self-avoiding, simple, and self-similar (FASS) curves, which includes Peano curves, and Morton z-curves.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Included are several variations of the Hilbert curve. They are type-stable and thoroughly tested, including bug fixes to amend the published algorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simple2D encodes two-dimensional Cartesian indices. Fastest and easiest to use.\nSpaceGray encodes multi-dimensional Cartesian indices that all have the same power-of-two extent. The fastest multi-dimensional version.\nGlobalGray like SpaceGray but a different pattern.\nFaceContinuous like SpaceGray and GlobalGray, but another pattern again.","category":"page"}]
}
